<script>
    var pollIntervalMin = 1000 * 60; 
    var pollIntervalMax = 1000 * 60 * 10;  
    var requestFailureCount = 0;  // used for exponential backoff
    var requestTimeout = 1000 * 60;
    var options = {};
    var data = {}; // current data
    var ts; // timestamp
    var scheduled = false;
    var summary = {};
    var count = 0;
    var defaults = {
        deepbit: {
            token: ''
        },
        slush: {
            token: ''
        },
        btcguild: {
            token: ''
        },
        btcmine: {
            token: ''
        },
        summary: true
    };
    
    function add(){
        var result = 0;
        var dp = 100000000; // decimal point for safety adding
        for(var i = 0; i < arguments.length; i++){
            result += parseInt(arguments[i] * dp, 10);
        }
        return result / dp;
    }
    
    var pool = {
        title: "",
        url: "",
        summaryfields: ["hashrate", "workers_formatted", "confirmed_reward", "unconfirmed_reward", "estimated_reward"],
        fields: [],
        init: function(){
            this.fields = this.summaryfields.concat(this.fields);
        },
        preprocess: function(){
            for(var field in this.fieldsMap){
                this.data[field] = this.data[this.fieldsMap[field]];
            }
        },
        process: function(){},
        postprocess: function(){
            this.data.hashrate = parseInt(this.data.hashrate, 10);            
            if(this.data.workers_all){
                this.data.workers_formatted = this.data.workers_alive + '/' + this.data.workers_all;    
            }            
            this.data.confirmed_reward = parseFloat(this.data.confirmed_reward);
            this.data.unconfirmed_reward = parseFloat(this.data.unconfirmed_reward);
            this.data.estimated_reward = parseFloat(this.data.estimated_reward);
            
            summary.workers_all += this.data.workers_all;
            summary.workers_alive += this.data.workers_alive;
            summary.workers_formatted = summary.workers_alive + '/' + summary.workers_all;
            summary.hashrate += this.data.hashrate;          
            console.log(this.title, this.data.hashrate, summary.hashrate);
            summary.confirmed_reward = add(summary.confirmed_reward, this.data.confirmed_reward);
            summary.unconfirmed_reward = add(summary.unconfirmed_reward, this.data.unconfirmed_reward);
            summary.estimated_reward = add(summary.estimated_reward, this.data.estimated_reward);                       
        }
    }
    
    var pools = {
        deepbit: {
            title: "deepbit.net",
            url: "https://deepbit.net/api/",
            fields: ["payout_history"],
            process: function(){                
                this.data.workers_alive = 0;
                this.data.workers_all = 0;                
                for (var i in  this.data.workers) {                   
                    this.data.workers_all++;
                    if( this.data.workers[i].alive){
                        this.data.workers_alive ++;
                    }                   
                }
                this.data.unconfirmed_reward = 0;
                this.data.estimated_reward = 0;
            }
        },
        slush: {
            title: "mining.bitcoin.cz",
            url: "http://mining.bitcoin.cz/accounts/profile/json/",
            fields: [],
            process: function(){                
                this.data.workers_alive = 0;
                this.data.workers_all = 0;
                this.data.hashrate = 0;                
                for (var i in this.data.workers) {                    
                    this.data.workers_all++;
                    this.data.hashrate += this.data.workers[i].hashrate;
                    
                    if(this.data.workers[i].alive){
                        this.data.workers_alive ++;
                    }                
                }
            }
        },
        btcguild: {
            title: "btcguild.com",
            url: "http://www.btcguild.com/api.php?api_key=",
            fields: ["payouts"],
            fieldsMap: {
                confirmed_reward: "confirmed_rewards",
                unconfirmed_reward: "unconfirmed_rewards",
                estimated_reward: "estimated_rewards"
            },
            preprocess: function(){
                for(var field in this.fieldsMap){
                    this.data.user[field] = this.data.user[this.fieldsMap[field]];
                }
            },
            process: function(){             
                var result = this.data.user;
                result.hashrate = 0;
                result.workers_alive = 0;
                result.workers_all = 0;
                for (var i in this.data.workers) {                    
                    result.workers_all++;
                    result.hashrate += this.data.workers[i].hash_rate;
                    
                    // 5 minutes delay
                    if(this.data.workers[i].last_share != 'never' &&
                        (new Date("1,1,1970 " + this.data.workers[i].last_share ).getTime()
                        - new Date("1,1,1970").getTime())/1000 < 5 * 60){
                        result.workers_alive++;
                    }                   
                }
                this.data = result;
            }
        },     
        btcmine: {
            title: "btcmine.com",
            url: "http://btcmine.com/api/getstats/",
            fields: ["total_bounty", "solved_blocks", "round_shares", "solved_shares", "total_payout"],
            fieldsMap: {
                confirmed_reward: "confirmed_bounty",
                unconfirmed_reward: "unconfirmed_bounty",
                estimated_reward: "estimated_bounty"
            },
            process: function(){
                var xhr = new XMLHttpRequest(); 
                var that = this;
                this.data.workers_all = 0;
                this.data.workers_alive = 0;
                try {
                    xhr.onreadystatechange = function(){
                        if (xhr.readyState != 4){
                            return;
                        }
                
                        if (xhr.status == 200 && xhr.responseText != ""){
                            var miners = JSON.parse(xhr.responseText); 
                            that.data.workers_all = miners.miners.length;                           
                            for(var i = 0; i < miners.miners.length; i++){
                                if(miners.miners[i].online_status){
                                    that.data.workers_alive++    
                                }                                
                            }
                            that.data.workers_formatted = that.data.workers_alive + '/' + that.data.workers_all;    
                        }                
                    }
            
                    xhr.onerror = function(error) {
                
                    }
            
                    xhr.open("GET", "http://btcmine.com/api/getminerstats/" + options.btcmine.token, true);
                    xhr.send(null);
                } catch(e) {
            
                }
            }
        }
    }
    
    // little inheritance
    for(var p in pools){
        for(field in pool){
            if(pools[p][field] == undefined){
                pools[p][field] = pool[field];
            }
        }
        pools[p].init();
    }    
    
    
    function updateOptions(){
        try {
            options = JSON.parse(localStorage.options);
        }catch(e){
        }    
        
        for(var pool in pools){
            if(options[pool].token){
                count++;
            }
        }
        if(count > 1){            
            defaults.summary = true;
        }else {
            defaults.summary = false;
        }
        
        for(var key in defaults){
            if(options[key] == undefined){
                options[key] = defaults[key];
            }
        }      
    }    
    
    function scheduleRequest() {
        if(!scheduled){
            scheduled = true;
            var randomness = Math.random() * 2;
            var exponent = Math.pow(2, requestFailureCount);
            var delay = Math.min(randomness * pollIntervalMin * exponent, 
            pollIntervalMax);
            delay = Math.round(delay);

            window.setTimeout(startRequest, delay); 
        }       
    }

    function startRequest() {
        summary =  {
            hashrate: 0,
            workers_all: 0,
            workers_alive: 0,            
            confirmed_reward: 0,
            unconfirmed_reward: 0,
            estimated_reward: 0
        };
        
        ts = new Date();
        
        for(var pool in pools){
            if(options[pool].token){
                console.log(pool);
                getData(pool,
                function(count) {            
                    scheduleRequest();
                },
                function() {            
                    scheduleRequest();
                });
            }else {
                delete data[pool];
            }
        }
        scheduled = false;
    }
    
    function getData(pool, onSuccess, onError) {        
        data[pool] = {
            status: 'Loading...'
        }
        var xhr = new XMLHttpRequest(); 
        var abortTimerId = window.setTimeout(function() {
            data[pool] = {
                status: 'Timeout'
            }
            xhr.abort();  // synchronously calls onreadystatechange
        }, requestTimeout);
        
        function handleError() {
            ++requestFailureCount;
            window.clearTimeout(abortTimerId);
            chrome.browserAction.setBadgeText({
                text: "!"
            });
            
            data[pool] = {
                status: 'Error'
            }
            
            chrome.browserAction.setBadgeBackgroundColor({
                color: [255, 0, 0, 255]
            });
            if (onError){                 
                onError();       
            }      
        }
        
        function handleSuccess(pool, result) {
            requestFailureCount = 0;
            chrome.browserAction.setBadgeText({
                text: ""
            });
            
            window.clearTimeout(abortTimerId);
            
            pools[pool].data = result;
            pools[pool].preprocess();
            pools[pool].process();
            pools[pool].postprocess();            
            data[pool] = pools[pool].data;
            
             
            var popup = chrome.extension.getViews({
                type: 'popup'
            });
            if(popup.length){
                popup[0].location.reload();
            }
            
            if (onSuccess){
                onSuccess();
            }
        }
        
        try {
            xhr.onreadystatechange = function(){
                if (xhr.readyState != 4){
                    return;
                }
                if(xhr.status != 200){
                    handleError();
                    return;
                }
                if(xhr.responseText != ""){
                    handleSuccess(pool, JSON.parse(xhr.responseText));    
                }                
            }

            xhr.onerror = function(error) {
                handleError();
            }
            
            xhr.open("GET", pools[pool].url + options[pool].token, true);
            xhr.send(null);
        } catch(e) {
            handleError();
        }
    }
    
    chrome.browserAction.onClicked.addListener(function(tab) {
        startRequest();
    });
    
    updateOptions();
    startRequest();

</script>
<script>
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-23642091-1']);
    _gaq.push(['_trackPageview']);
            
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = 'https://ssl.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>