<script>
    var pollIntervalMin = 1000 * 60; 
    var pollIntervalMax = 1000 * 60 * 10;  
    var requestFailureCount = 0;  // used for exponential backoff
    var requestTimeout = 1000 * 60;
    var options = {};
    var data = {}; // current data
    var scheduled = false;
    
    var pools = {
        deepbit: {
            title: "deepbit.net",
            url: "https://deepbit.net/api/",
            fields: ["hashrate", "workers_formatted", "confirmed_reward", "payout_history"],
            hydrate: function(data){
                data.workers_alive = 0;
                data.workers_all = 0;                
                for (var i in data.workers) {                   
                    data.workers_all++;
                    if(data.workers[i].alive){
                        data.workers_alive ++;
                    }                   
                }
                data.hashrate = parseInt(data.hashrate, 10);
                data.workers_formatted = data.workers_alive + '/' + data.workers_all;
                return data;
            }
        },
        slush: {
            title: "mining.bitcoin.cz",
            url: "http://mining.bitcoin.cz/accounts/profile/json/",
            fields: ["hashrate", "workers_formatted", "confirmed_reward", "unconfirmed_reward", "estimated_reward"],
            hydrate: function(data){                
                data.workers_alive = 0;
                data.workers_all = 0;
                data.hashrate = 0;                
                for (var i in data.workers) {                    
                    data.workers_all++;
                    data.hashrate += data.workers[i].hashrate;
                    
                    if(data.workers[i].alive){
                        data.workers_alive ++;
                    }                
                }      
                data.workers_formatted = data.workers_alive + '/' + data.workers_all;                
                return data;
            }
        },
        btcguild: {
            title: "btcguild.com",
            url: "http://www.btcguild.com/api.php?api_key=",
            fields: ["hashrate", "workers_formatted", "confirmed_rewards", "unconfirmed_rewards", "estimated_rewards", "payouts"],
            hydrate: function(data){             
                var result = data.user;
                var hashrate = 0;
                result.workers_alive = 0;
                result.workers_all = 0;
                for (var i in data.workers) {                    
                    result.workers_all++;
                    hashrate += data.workers[i].hash_rate;
                    
                    // 5 minutes delay
                    if(data.workers[i].last_share != 'never' &&
                        (new Date("1,1,1970 " + data.workers[i].last_share ).getTime()
                        - new Date("1,1,1970").getTime())/1000 < 5 * 60){
                        result.workers_alive++;
                    }                   
                }                
                result.hashrate = parseInt(hashrate, 10);
                result.workers_formatted = result.workers_alive + '/' + result.workers_all;
                return result;
            }
        },     
        btcmine: {
            title: "btcmine.com",
            url: "http://btcmine.com/api/getstats/",
            fields: ["total_payout", "total_bounty", "confirmed_bounty", "solved_blocks", "estimated_bounty", "round_shares", "unconfirmed_bounty", "hashrate", "solved_shares"],
            hydrate: function(data){
                return data;
            }
        }
    }
    
    
    
    function updateOptions(){
        try {
            options = JSON.parse(localStorage.options);
        }catch(e){
        }
        var defaults = {
            deepbit: {
                token: ''
            },
            slush: {
                token: ''
            },
            btcguild: {
                token: ''
            },
            btcmine: {
                token: ''
            }
        };
        for(var key in defaults){
            if(options[key] == undefined){
                options[key] = defaults[key];
            }
        }        
    }    
    
    function scheduleRequest() {
        if(!scheduled){
            scheduled = true;
            var randomness = Math.random() * 2;
            var exponent = Math.pow(2, requestFailureCount);
            var delay = Math.min(randomness * pollIntervalMin * exponent, 
            pollIntervalMax);
            delay = Math.round(delay);

            window.setTimeout(startRequest, delay); 
        }       
    }

    function startRequest() {
        for(var pool in pools){
            if(options[pool].token){
                console.log(pool);
                getData(pool,
                function(count) {            
                    scheduleRequest();
                },
                function() {            
                    scheduleRequest();
                });
            }
        }
        scheduled = false;
    }
    
    function getData(pool, onSuccess, onError) {
        var xhr = new XMLHttpRequest(); 
        var abortTimerId = window.setTimeout(function() {
            data[pool] = {
                error: 'Timeout'
            }
            xhr.abort();  // synchronously calls onreadystatechange
        }, requestTimeout);
        
        function handleError() {
            ++requestFailureCount;
            window.clearTimeout(abortTimerId);
            chrome.browserAction.setBadgeText({
                text: "!"
            });
            
            data[pool] = {
                error: 'Error'
            }
            
            chrome.browserAction.setBadgeBackgroundColor({
                color: [255, 0, 0, 255]
            });
            if (onError){                 
                onError();       
            }      
        }
        
        function handleSuccess(pool, result) {
            requestFailureCount = 0;
            chrome.browserAction.setBadgeText({
                text: ""
            });
            
            window.clearTimeout(abortTimerId);
            data[pool] = pools[pool].hydrate(result);
            
            if (onSuccess){
                onSuccess(data);
            }
        }
        
        try {
            xhr.onreadystatechange = function(){
                if (xhr.readyState != 4){
                    return;
                }
                if(xhr.status != 200){
                    handleError();
                    return;
                }
                if(xhr.responseText != ""){
                    handleSuccess(pool, JSON.parse(xhr.responseText));    
                }                
            }

            xhr.onerror = function(error) {
                handleError();
            }
            
            xhr.open("GET", pools[pool].url + options[pool].token, true);
            xhr.send(null);
        } catch(e) {
            handleError();
        }
    }
    
    chrome.browserAction.onClicked.addListener(function(tab) {
        startRequest();
    });
    
    updateOptions();
    startRequest();

</script>
